<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backrooms Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
            position: relative;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .bar-container {
            margin-bottom: 15px;
            width: 300px;
        }
        
        .bar-label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #ccc;
        }
        
        .bar {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #555;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .stamina { background: linear-gradient(90deg, #4a9eff, #0066cc); }
        .noise { background: linear-gradient(90deg, #55dd55, #ffcc00, #ff3b3b); }
        .battery { background: linear-gradient(90deg, #00ff00, #ff8800, #ff0000); }
        
        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            border-radius: 8px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #aaa;
            z-index: 1000;
            pointer-events: none;
        }
        
        .inventory {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
        }
        
        .btn {
            padding: 12px 24px;
            margin: 10px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #0066cc;
        }
        
        #pickupHint {
            position: fixed;
            left: 50%;
            bottom: 100px;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            display: none;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud">
        <div class="bar-container">
            <div class="bar-label">Endurance (Shift = courir)</div>
            <div class="bar">
                <div id="staminaBar" class="bar-fill stamina" style="width: 100%;"></div>
            </div>
        </div>
        
        <div class="bar-container">
            <div class="bar-label">Bruit</div>
            <div class="bar">
                <div id="noiseBar" class="bar-fill noise" style="width: 0%;"></div>
            </div>
        </div>
        
        <div class="bar-container" id="batteryContainer" style="display: none;">
            <div class="bar-label">Batterie Lampe</div>
            <div class="bar">
                <div id="batteryBar" class="bar-fill battery" style="width: 100%;"></div>
            </div>
        </div>
    </div>
    
    <div class="inventory">
        <div>Inventaire:</div>
        <div id="inventoryItems">(vide)</div>
        <div style="margin-top: 10px; font-size: 12px;">
            F: Allumer/Éteindre lampe<br>
            R: Poser piège<br>
            E: Ramasser objet
        </div>
    </div>
    
    <div class="minimap">
        <div style="text-align: center; padding: 5px; font-size: 12px;">Minimap</div>
        <canvas id="minimapCanvas" width="196" height="120"></canvas>
    </div>
    
    <div class="controls">
        ZQSD / Flèches: Se déplacer<br>
        Shift: Courir<br>
        F: Lampe | R: Piège | E: Ramasser
    </div>
    
    <div id="pickupHint">Appuyer sur E pour ramasser</div>
    
    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">Game Over</h2>
        <p id="gameOverMessage">Vous avez été attrapé par un monstre!</p>
        <button class="btn" id="restartBtn">Recommencer</button>
        <button class="btn" id="menuBtn" style="display: none;">Menu</button>
    </div>

    <script>
        // Configuration du jeu
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // Dimensions
        const TILE_SIZE = 30;
        const MAP_WIDTH = 60;
        const MAP_HEIGHT = 45;
        const WORLD_WIDTH = MAP_WIDTH * TILE_SIZE;
        const WORLD_HEIGHT = MAP_HEIGHT * TILE_SIZE;
        
        // Redimensionner le canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Variables du jeu
        let gameState = 'playing';
        let map = [];
        let litAreas = [];
        let camera = { x: 0, y: 0 };
        
        // Joueur
        let player = {
            x: 300,
            y: 300,
            radius: 12,
            speed: 120,
            runSpeed: 200,
            stamina: 100,
            maxStamina: 100,
            staminaDrain: 40,
            staminaRegen: 20,
            noise: 0,
            maxNoise: 100,
            hasFlashlight: false,
            flashlightOn: false,
            battery: 100,
            maxBattery: 100,
            batteryDrain: 25,
            traps: 0
        };
        
        // Monstres
        let monsters = [];
        
        // Objets
        let items = [];
        let traps = [];
        
        // Porte
        let door = { x: 0, y: 0 };
        
        // Contrôles
        let keys = {};
        
        // Initialisation
        function init() {
            generateMap();
            placeItems();
            placeDoor();
            spawnMonsters();
            
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }
        
        // Génération de la carte
        function generateMap() {
            map = [];
            litAreas = [];
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                litAreas[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1) {
                        map[y][x] = 1;
                    } else {
                        map[y][x] = Math.random() < 0.3 ? 1 : 0;
                    }
                    litAreas[y][x] = false;
                }
            }
            
            // Zones lumineuses
            for (let i = 0; i < 15; i++) {
                const centerX = Math.floor(Math.random() * (MAP_WIDTH - 4)) + 2;
                const centerY = Math.floor(Math.random() * (MAP_HEIGHT - 4)) + 2;
                const radius = 3 + Math.floor(Math.random() * 4);
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = centerX + dx;
                        const y = centerY + dy;
                        if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance <= radius && Math.random() < 0.8) {
                                litAreas[y][x] = true;
                            }
                        }
                    }
                }
            }
            
            player.x = TILE_SIZE * 2;
            player.y = TILE_SIZE * 2;
        }
        
        // Placement des objets
        function placeItems() {
            items = [];
            const itemTypes = ['flashlight', 'energy_bar', 'energy_bar', 'energy_bar', 'battery', 'battery', 'battery', 'trap', 'trap', 'trap'];
            
            for (let i = 0; i < 30; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (MAP_WIDTH - 2)) + 1;
                    y = Math.floor(Math.random() * (MAP_HEIGHT - 2)) + 1;
                } while (map[y][x] === 1);
                
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                items.push({
                    x: x * TILE_SIZE + TILE_SIZE / 2,
                    y: y * TILE_SIZE + TILE_SIZE / 2,
                    type: type,
                    collected: false
                });
            }
        }
        
        // Placement de la porte
        function placeDoor() {
            let x, y;
            do {
                x = Math.floor(Math.random() * (MAP_WIDTH - 2)) + 1;
                y = Math.floor(Math.random() * (MAP_HEIGHT - 2)) + 1;
            } while (map[y][x] === 1 || Math.sqrt((x * TILE_SIZE - player.x) ** 2 + (y * TILE_SIZE - player.y) ** 2) < 400);
            
            door.x = x * TILE_SIZE + TILE_SIZE / 2;
            door.y = y * TILE_SIZE + TILE_SIZE / 2;
        }
        
        // Spawn des monstres
        function spawnMonsters() {
            monsters = [];
            
            // 3 monstres errants
            for (let i = 0; i < 3; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (MAP_WIDTH - 2)) + 1;
                    y = Math.floor(Math.random() * (MAP_HEIGHT - 2)) + 1;
                } while (map[y][x] === 1);
                
                monsters.push({
                    x: x * TILE_SIZE + TILE_SIZE / 2,
                    y: y * TILE_SIZE + TILE_SIZE / 2,
                    radius: 15,
                    speed: 60,
                    type: 'roamer',
                    alertLevel: 0,
                    targetX: null,
                    targetY: null,
                    stunned: 0
                });
            }
            
            // 1 monstre gardien
            monsters.push({
                x: door.x + 50,
                y: door.y + 50,
                radius: 18,
                speed: 50,
                type: 'guard',
                alertLevel: 0,
                targetX: door.x,
                targetY: door.y,
                stunned: 0
            });
        }
        
        // Gestion des entrées clavier
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'e') {
                collectItems();
                e.preventDefault();
            } else if (e.key.toLowerCase() === 'f') {
                toggleFlashlight();
                e.preventDefault();
            } else if (e.key.toLowerCase() === 'r') {
                placeTrap();
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code.toLowerCase()] = false;
        });
        
        // Boucle principale
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (gameState === 'playing') {
                update(deltaTime);
            }
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Mise à jour du jeu
        function update(deltaTime) {
            updatePlayer(deltaTime);
            updateMonsters(deltaTime);
            updateCamera();
            updateUI();
            checkCollisions();
        }
        
        // Mise à jour du joueur
        function updatePlayer(deltaTime) {
            let dx = 0, dy = 0;
            
            if (keys['z'] || keys['arrowup'] || keys['w']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['q'] || keys['arrowleft'] || keys['a']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;
            
            if (dx !== 0 || dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx /= length;
                dy /= length;
                
                const isRunning = keys['shift'] && player.stamina > 0;
                const speed = isRunning ? player.runSpeed : player.speed;
                
                const newX = player.x + dx * speed * deltaTime;
                const newY = player.y + dy * speed * deltaTime;
                
                if (!isWall(newX, player.y)) {
                    player.x = newX;
                }
                if (!isWall(player.x, newY)) {
                    player.y = newY;
                }
                
                if (isRunning) {
                    player.stamina -= player.staminaDrain * deltaTime;
                    player.noise += 80 * deltaTime;
                } else {
                    player.stamina += player.staminaRegen * deltaTime;
                }
                
                player.stamina = Math.max(0, Math.min(player.maxStamina, player.stamina));
            } else {
                player.stamina += player.staminaRegen * deltaTime;
                player.noise -= 30 * deltaTime;
            }
            
            player.noise = Math.max(0, Math.min(player.maxNoise, player.noise));
            
            if (player.flashlightOn && player.battery > 0) {
                player.battery -= player.batteryDrain * deltaTime;
                if (player.battery <= 0) {
                    player.flashlightOn = false;
                }
            }
        }
        
        // Vérifier si une position est un mur
        function isWall(x, y) {
            const mapX = Math.floor(x / TILE_SIZE);
            const mapY = Math.floor(y / TILE_SIZE);
            
            if (mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT) {
                return true;
            }
            
            return map[mapY][mapX] === 1;
        }
        
        // Fonction de pathfinding simple pour contourner les murs
        function findPath(startX, startY, targetX, targetY) {
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 50) {
                return { x: targetX, y: targetY };
            }
            
            // Vérifier si le chemin direct est libre
            const steps = Math.ceil(distance / 20);
            let blocked = false;
            
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const checkX = startX + dx * t;
                const checkY = startY + dy * t;
                
                if (isWall(checkX, checkY)) {
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked) {
                return { x: targetX, y: targetY };
            }
            
            // Si bloqué, essayer de contourner
            const angle = Math.atan2(dy, dx);
            const perpendicular1 = angle + Math.PI / 2;
            const perpendicular2 = angle - Math.PI / 2;
            
            // Essayer les deux directions perpendiculaires
            for (let direction of [perpendicular1, perpendicular2]) {
                const offset = 40;
                const testX = startX + Math.cos(direction) * offset;
                const testY = startY + Math.sin(direction) * offset;
                
                if (!isWall(testX, testY)) {
                    // Vérifier si on peut rejoindre la cible depuis ce point
                    const testDx = targetX - testX;
                    const testDy = targetY - testY;
                    const testDistance = Math.sqrt(testDx * testDx + testDy * testDy);
                    const testSteps = Math.ceil(testDistance / 20);
                    let canReach = true;
                    
                    for (let i = 1; i <= testSteps; i++) {
                        const t = i / testSteps;
                        const checkX = testX + testDx * t;
                        const checkY = testY + testDy * t;
                        
                        if (isWall(checkX, checkY)) {
                            canReach = false;
                            break;
                        }
                    }
                    
                    if (canReach) {
                        return { x: testX, y: testY };
                    }
                }
            }
            
            // Si tout échoue, essayer de bouger dans la direction générale
            const stepSize = 30;
            const stepX = startX + Math.cos(angle) * stepSize;
            const stepY = startY + Math.sin(angle) * stepSize;
            
            if (!isWall(stepX, stepY)) {
                return { x: stepX, y: stepY };
            }
            
            // Dernière tentative : mouvement aléatoire
            for (let i = 0; i < 8; i++) {
                const randomAngle = Math.random() * Math.PI * 2;
                const randomX = startX + Math.cos(randomAngle) * stepSize;
                const randomY = startY + Math.sin(randomAngle) * stepSize;
                
                if (!isWall(randomX, randomY)) {
                    return { x: randomX, y: randomY };
                }
            }
            
            // Si vraiment bloqué, rester sur place
            return { x: startX, y: startY };
        }

        // Mise à jour des monstres avec IA améliorée
        function updateMonsters(deltaTime) {
            for (let monster of monsters) {
                if (monster.stunned > 0) {
                    monster.stunned -= deltaTime;
                    continue;
                }
                
                const distanceToPlayer = Math.sqrt((monster.x - player.x) ** 2 + (monster.y - player.y) ** 2);
                const noiseRadius = 80 + (player.noise * 3);
                
                // Détection améliorée
                if (distanceToPlayer < noiseRadius || (player.flashlightOn && distanceToPlayer < 200)) {
                    monster.alertLevel = Math.min(100, monster.alertLevel + 80 * deltaTime);
                    // Utiliser le pathfinding pour atteindre le joueur
                    const path = findPath(monster.x, monster.y, player.x, player.y);
                    monster.targetX = path.x;
                    monster.targetY = path.y;
                } else {
                    monster.alertLevel = Math.max(0, monster.alertLevel - 15 * deltaTime);
                }
                
                // Comportement spécifique selon le type
                if (monster.type === 'guard') {
                    const doorDistance = Math.sqrt((monster.x - door.x) ** 2 + (monster.y - door.y) ** 2);
                    if (doorDistance > 60 && monster.alertLevel < 40) {
                        const path = findPath(monster.x, monster.y, door.x, door.y);
                        monster.targetX = path.x;
                        monster.targetY = path.y;
                    }
                } else if (monster.alertLevel < 25) {
                    // Errance intelligente avec pathfinding
                    if (!monster.targetX || Math.random() < 0.008) {
                        const searchRadius = 300;
                        const attempts = 20;
                        for (let i = 0; i < attempts; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * searchRadius;
                            const targetX = player.x + Math.cos(angle) * distance;
                            const targetY = player.y + Math.sin(angle) * distance;
                            
                            const mapX = Math.floor(targetX / TILE_SIZE);
                            const mapY = Math.floor(targetY / TILE_SIZE);
                            
                            if (mapX > 0 && mapX < MAP_WIDTH - 1 && mapY > 0 && mapY < MAP_HEIGHT - 1 && map[mapY][mapX] === 0) {
                                const path = findPath(monster.x, monster.y, targetX, targetY);
                                monster.targetX = path.x;
                                monster.targetY = path.y;
                                break;
                            }
                        }
                    }
                }
                
                // Mouvement avec pathfinding
                if (monster.targetX && monster.targetY) {
                    const dx = monster.targetX - monster.x;
                    const dy = monster.targetY - monster.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 8) {
                        const speedMultiplier = monster.alertLevel > 50 ? 1.5 : 1.0;
                        const moveX = (dx / distance) * monster.speed * speedMultiplier * deltaTime;
                        const moveY = (dy / distance) * monster.speed * speedMultiplier * deltaTime;
                        
                        // Vérifier les collisions avant de bouger
                        const newX = monster.x + moveX;
                        const newY = monster.y + moveY;
                        
                        if (!isWall(newX, monster.y)) {
                            monster.x = newX;
                        }
                        if (!isWall(monster.x, newY)) {
                            monster.y = newY;
                        }
                        
                        // Si on ne peut pas bouger dans la direction voulue, recalculer le chemin
                        if (isWall(newX, monster.y) && isWall(monster.x, newY)) {
                            const path = findPath(monster.x, monster.y, monster.targetX, monster.targetY);
                            monster.targetX = path.x;
                            monster.targetY = path.y;
                        }
                    } else {
                        // Atteint la cible, la nettoyer
                        monster.targetX = null;
                        monster.targetY = null;
                    }
                }
            }
        }
        
        // Mise à jour de la caméra
        function updateCamera() {
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;
            
            camera.x += (targetX - camera.x) * 0.1;
            camera.y += (targetY - camera.y) * 0.1;
            
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));
        }
        
        // Mise à jour de l'interface
        function updateUI() {
            document.getElementById('staminaBar').style.width = (player.stamina / player.maxStamina * 100) + '%';
            document.getElementById('noiseBar').style.width = (player.noise / player.maxNoise * 100) + '%';
            
            if (player.hasFlashlight) {
                document.getElementById('batteryContainer').style.display = 'block';
                document.getElementById('batteryBar').style.width = (player.battery / player.maxBattery * 100) + '%';
            }
            
            let inventoryText = '';
            if (player.hasFlashlight) inventoryText += 'Lampe ';
            if (player.traps > 0) inventoryText += `Pièges:${player.traps} `;
            if (inventoryText === '') inventoryText = '(vide)';
            
            document.getElementById('inventoryItems').textContent = inventoryText;
            
            let nearItem = false;
            for (let item of items) {
                if (!item.collected) {
                    const distance = Math.sqrt((item.x - player.x) ** 2 + (item.y - player.y) ** 2);
                    if (distance < 35) {
                        nearItem = true;
                        break;
                    }
                }
            }
            
            document.getElementById('pickupHint').style.display = nearItem ? 'block' : 'none';
        }
        
        // Collecte d'objets
        function collectItems() {
            for (let item of items) {
                if (!item.collected) {
                    const distance = Math.sqrt((item.x - player.x) ** 2 + (item.y - player.y) ** 2);
                    if (distance < 25) {
                        item.collected = true;
                        
                        switch (item.type) {
                            case 'flashlight':
                                player.hasFlashlight = true;
                                player.battery = player.maxBattery;
                                break;
                            case 'energy_bar':
                                player.stamina = Math.min(player.maxStamina, player.stamina + 50);
                                break;
                            case 'battery':
                                if (player.hasFlashlight) {
                                    player.battery = Math.min(player.maxBattery, player.battery + 50);
                                }
                                break;
                            case 'trap':
                                player.traps++;
                                break;
                        }
                    }
                }
            }
        }
        
        // Allumer/éteindre la lampe
        function toggleFlashlight() {
            if (player.hasFlashlight && player.battery > 0) {
                player.flashlightOn = !player.flashlightOn;
            }
        }
        
        // Poser un piège
        function placeTrap() {
            if (player.traps > 0) {
                traps.push({
                    x: player.x,
                    y: player.y,
                    radius: 15,
                    active: true
                });
                player.traps--;
            }
        }
        
        // Vérification des collisions
        function checkCollisions() {
            for (let monster of monsters) {
                const distance = Math.sqrt((monster.x - player.x) ** 2 + (monster.y - player.y) ** 2);
                if (distance < monster.radius + player.radius) {
                    gameOver();
                    return;
                }
            }
            
            const doorDistance = Math.sqrt((door.x - player.x) ** 2 + (door.y - player.y) ** 2);
            if (doorDistance < 20) {
                victory();
                return;
            }
            
            for (let i = traps.length - 1; i >= 0; i--) {
                const trap = traps[i];
                if (trap.active) {
                    for (let monster of monsters) {
                        const distance = Math.sqrt((trap.x - monster.x) ** 2 + (trap.y - monster.y) ** 2);
                        if (distance < trap.radius + monster.radius) {
                            monster.stunned = 5;
                            trap.active = false;
                            traps.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        
        // Game Over
        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('gameOverTitle').textContent = 'Game Over';
            document.getElementById('gameOverMessage').textContent = 'Vous avez été attrapé par un monstre!';
            document.getElementById('restartBtn').style.display = 'inline-block';
            document.getElementById('menuBtn').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Victoire
        function victory() {
            gameState = 'victory';
            document.getElementById('gameOverTitle').textContent = 'Victoire!';
            document.getElementById('gameOverMessage').textContent = 'Le code est ---9--';
            document.getElementById('restartBtn').style.display = 'none';
            document.getElementById('menuBtn').style.display = 'inline-block';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Rendu
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const startX = Math.floor(camera.x / TILE_SIZE);
            const startY = Math.floor(camera.y / TILE_SIZE);
            const endX = Math.min(MAP_WIDTH, Math.ceil((camera.x + canvas.width) / TILE_SIZE) + 1);
            const endY = Math.min(MAP_HEIGHT, Math.ceil((camera.y + canvas.height) / TILE_SIZE) + 1);
            
            // Rendre la carte
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;
                    
                    if (map[y][x] === 1) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    } else {
                        if (litAreas[y][x]) {
                            ctx.fillStyle = '#f0f0a0';
                        } else {
                            ctx.fillStyle = '#666';
                        }
                        ctx.fillRect(screenX, screenY